#version 330 
#extension GL_ARB_explicit_uniform_location : require
#extension GL_ARB_shading_language_420pack : require
layout (location = 0) in vec3 in_pos;
uniform vec3 offset;
uniform float scale;
uniform mat4 unview;
uniform mat4 perspective;
out vec3 normal;
out vec3 vpos;
out vec3 mpos;

void main(void)
{
	mpos = in_pos;
	normal = vec3(unview * vec4(mpos, 0.0));
	vpos = offset + scale * normal;
	gl_Position = perspective * vec4(vpos, 1.0);
}

~ SEPARATOR ~

#version 330 
#extension GL_ARB_explicit_uniform_location : require
in vec3 normal;
in vec3 vpos;
in vec3 mpos;
out vec4 result;
uniform vec3 light_pos;
uniform vec3 camera_pos;
uniform bool control_mode;

vec3 CalcPointLight(vec3 light_pos)
{
    vec3 lightDir = normalize(light_pos - vpos);
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 reflectDir = reflect(-lightDir, normal);
	vec3 viewDir = camera_pos - vpos;
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 8);
    float distance = length(light_pos - vpos);
    float attenuation = 1.0 / (1.0 + 0.07 * distance + 0.017 * (distance * distance));    
    vec3 ambient = vec3(1.0);
    vec3 diffuse = diff * vec3(0.5);
    vec3 specular = spec * vec3(0.5);
	vec3 result = ambient + diffuse + specular;
	result *= attenuation;
    return result;
}

void main(void)
{
	vec3 color = vec3(
		1.0,
		sin(normal.y * normal.x) * 0.3 + 0.7,
		sin(normal.z * normal.x) * 0.3 + 0.7
	);

	vec3 dir = normal;

	if (control_mode == false) dir = -mpos;

	if (dir.z > 0.7) color = vec3(1.0, 1.0, 1.0);
	if (dir.z > 0.9){
		if (control_mode == true){
			color = vec3(5.0, 0.0, 0.0);
		}else{
			color = vec3(0.0, 0.0, 0.0);
		}
	}
	color *= CalcPointLight(light_pos);

	result = vec4(color, 0.5);
} 
